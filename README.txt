Види гілок:
- main
- release/*
- feature/* чи hotfix/*
- develop

Процес розробки:
Для розробки нових функцій використовуються гілки feature/*. Гілки feature/* автоматично не білдяться. Коли розробка функції завершена і треба підготувати гілку до мерджа створюється PR в develop. PR автоматично трігерить білд, який перевіряє, чи компілюється код в feature/* гілці перед тим як мержити в develop. Змержити гілку поки ця перевірка не пройде заборонено політиками.
Коли нова функція попадає в develop автоматично тігериться процедура білда та деплоя на sandbox середовище.
Як тільки вирішено, що необхідно зробити новий реліз на прод створюється гілка release/* з develop. Назва гілки може бути будь-яка, але бажано не включати в неї номер версії, тому що це може створити плутанину. Я пропоную називати гілки датою  реліза. З release/* є можливість білдити та деплоїти застосунок в stage середовище, вручну запустивши пайплайн.
Поки реліз готується та тестується develop гілка буде рухатися до наступного реліза, тому release/* та develop можуть розходитися, це нормально. Якщо підчас тестування знайшли баги які потребують хотфікса, тоді створюється гілка hotfix/* з release/*, в ній виконуються потрібні зміни, тестуються на stage середовищі. Коли hotfix готовий - гілка мержиться в release/*. Я не впевнений, що потрібно робити PR валідацію для гілок hotfix/* (хотфікси це виключення). Гілка hotfix/* в develop _не мержиться_.
Як тільки release/* гілка готова до релізу запускається release пайплайн з цієї гілки. Пайплайн автоматично визначає версію і маркує цей коміт відповідним тегом. Після успішного реліза гілка release/* мержиться в main, а main мержиться в develop. Таким чином, всі хотфікси зроблені в гілці release/* потрапляють в develop. Якщо реліз не успішний і необхідні термінові виправлення, то їх можна виконати в тій самій release/* гілці. Тут важливо, що версія реліза автоматично буде інкрементована в цьому випадку. Це можна обійти, але це додає потенційні ризики і варто цього уникати.

Для версіонування використовується інструмент gitversion. Цей інструмент автоматично інкрементує версії відповідно до існуючих тегів та підказок в описі коміта. Версія виглядає як <major>.<minor>.<patch>. Інструмент gitversion автоматично створює тег при релізі. Наступного разу, при релізі gitversion детектує раніше створений тег і інкрементує patch версію. Якщо потрібно інкрементувати major або minor можна використати спеціальні команди в описі коміта (на початку), наприклад: "+semver: major" або "+semver: minor". Якщо між релізами буде кілька комітів які інкрементують, наприклад, minor, то це не призведе до інкрементування версії на 2, лише на 1.
Для develop гілки версіонування дещо відрізняється: <major>.<minor>.<patch>-<increment>. Пайплайн на sandbox середовище автоматично інкрементує <increment> частину і не чіпає <major>, <minor> або <patch> (якщо не використовувати команди в описі коміта). Це дозволяє розрізняти версії на sandbox середовищі і при цьому це не впливає на релізну версію.